<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>DR Event • Radial Clock (Historic, URL-driven)</title>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
<style>
  :root{
    --bg:#0f1115; --panel:#161a22; --muted:#8b93a7; --text:#e9eefb;
    --standby:#f5d76e; --activation:#ff9f43; --event:#ff5252;
    --tick:#2b3242; --ring:#222735;
  }
  html,body{height:100%}
  body{
    margin:0; background:var(--bg); color:var(--text); font-family:Inter,system-ui,Arial,sans-serif;
    display:flex; align-items:center; justify-content:center; padding:24px;
  }
  .wrap{max-width:980px; width:100%; display:grid; gap:16px; grid-template-columns: 520px 1fr;}
  .card{background:var(--panel); border:1px solid #1e2430; border-radius:14px; padding:16px;}
  h1{font-size:18px; margin:0 0 8px}
  .muted{color:var(--muted); font-size:12px}
  .legend{display:flex; gap:10px; flex-wrap:wrap; margin-top:8px}
  .chip{display:inline-flex; align-items:center; gap:6px; font-size:12px; padding:4px 8px; border-radius:999px; background:#121621; border:1px solid #222a38}
  .dot{width:10px; height:10px; border-radius:50%}
  .dot.standby{background:var(--standby)}
  .dot.activation{background:var(--activation)}
  .dot.event{background:var(--event)}
  .clock-wrap{display:flex; align-items:center; justify-content:center; position:relative}
  svg{overflow:visible; display:block}
  .tip{position:absolute; pointer-events:none; background:#0b0f16; border:1px solid #283042; padding:8px 10px; border-radius:8px; font-size:12px; color:var(--text); box-shadow:0 6px 18px rgba(0,0,0,.35); opacity:0; transform:translate(-50%,-120%); transition:opacity .12s}
.tip{ z-index:9999; }

  .kpis{display:grid; grid-template-columns: repeat(2,minmax(0,1fr)); gap:10px; margin-top:8px}
  .kpi{background:#121621; border:1px solid #20283a; border-radius:12px; padding:10px}
  .kpi .label{font-size:11px; color:var(--muted)}
  .kpi .value{font-size:20px; font-weight:700}
  .footer{font-size:12px; color:var(--muted); margin-top:8px}
  @media (max-width:900px){ .wrap{grid-template-columns:1fr} }
  
</style>
</head>
<body>
<div class="wrap">
  <div class="card">
    <h1>Radial Event Clock (Historic)</h1>
    <div class="muted">Completed phases shown as a single aligned ring on a 24-hour dial (timezone-aware). Hover for details.</div>
    <div class="legend">
      <span class="chip"><span class="dot standby"></span>Standby → Activation</span>
      <span class="chip"><span class="dot activation"></span>Activation → Start</span>
      <span class="chip"><span class="dot event"></span>Event Window</span>
    </div>
    <div class="clock-wrap" id="clock-host" style="margin-top:8px;">
      <div class="tip" id="tip"></div>
    </div>
    <div class="footer" id="footerText">—</div>
  </div>

  <div class="card">
    <h1>Event Summary</h1>
    <div class="kpis">
      <div class="kpi"><div class="label">Event Window</div><div class="value" id="k_event">—</div></div>
      <div class="kpi"><div class="label">Lead Time (Activation → Start)</div><div class="value" id="k_lead">—</div></div>
      <div class="kpi"><div class="label">Standby Lead (Standby → Activation)</div><div class="value" id="k_sb">—</div></div>
      <div class="kpi"><div class="label">Dial Day</div><div class="value" id="k_day">—</div></div>
    </div>
    <div class="footer">URL params: <code>eventId,useCase,eventDate,start,end,standby,activation,fmt,tz,offset</code></div>
  </div>
</div>

<script>
/* ====== URL CONFIG (extra-robust for QuickSight & double-encoding) ====== */
function multiDecode(s) {
  // decode repeatedly in case we get %2526, etc.
  let out = s || "";
  for (let i = 0; i < 3; i++) {
    try {
      const dec = decodeURIComponent(out);
      if (dec === out) break;
      out = dec;
    } catch {
      break;
    }
  }
  return out;
}

function getQSParams() {
  // 1) start with the normal search
  let raw = window.location.search;

  // 2) if empty, try to pull query after ".html" in the href (QS quirk)
  if (!raw || raw === "?") {
    const hrefDec = multiDecode(window.location.href);
    const m = hrefDec.match(/\.html(\?[^#]*)/i);
    if (m) raw = m[1];
  }

  // 3) normalize: strip "?", unescape any "&amp;"
  if (!raw) raw = "";
  let normalized = raw.replace(/^\?/, "").replace(/&amp;/g, "&");

  // 4) decode % encodings (turn %26 into &) and build params
  normalized = multiDecode("?" + normalized).slice(1);
  return new URLSearchParams(normalized);
}

const p = getQSParams();

const cfg = {
  tz: p.get("tz") || "Asia/Dubai",
  offset: p.get("offset") || "+04:00",
  eventId: p.get("eventId") || "—",
  useCase: p.get("useCase") || "—",
  fmt: (p.get("fmt") || "").toUpperCase(), // "DMY" or ""
  eventDate: p.get("eventDate") || "",
  standby:   p.get("standby")   || "",
  activation:p.get("activation")|| "",
  start:     p.get("start")     || "",
  end:       p.get("end")       || ""
};




/* ====== PARSERS ====== */
// pad helper
const z = (n)=> (n<10? "0"+n : ""+n);

// Turn "DD/MM/YYYY" -> {yyyy,mm,dd}
function splitDMY(dmy){
  const [dd,MM,yyyy] = dmy.split(/[\/\-\.]/).map(s=>s.trim());
  return { yyyy, mm: z(+MM), dd: z(+dd) };
}
// Turn "DD/MM/YYYY HH:mm" -> ISO with fixed offset (e.g., +04:00)
function DMY_HHMM_toISO(s, offset="+04:00", defaultTime="00:00"){
  const [d, tRaw] = s.split(" ");
  const { yyyy, mm, dd } = splitDMY(d);
  const t = tRaw ? tRaw.trim() : defaultTime;
  const [HH,MM] = t.split(":");
  return `${yyyy}-${mm}-${dd}T${z(+HH||0)}:${z(+MM||0)}:00${offset}`;
}

// Flexible parse: accepts ISO or DMY (when cfg.fmt==="DMY")
function parseFlex(s, { isDateOnly=false } = {}){
  if(!s) return null;
  const looksISO = /\d{4}-\d{2}-\d{2}T/.test(s) || /Z$|[+\-]\d{2}:\d{2}$/.test(s);
  if(looksISO){
    return new Date(s);
  }else if(cfg.fmt === "DMY"){
    // if only a date is provided, no time: use 00:00
    const iso = isDateOnly ? DMY_HHMM_toISO(s, cfg.offset, "00:00")
                           : DMY_HHMM_toISO(s, cfg.offset);
    return new Date(iso);
  }else{
    // Fallback: try native (may assume local TZ)
    return new Date(s);
  }
}

/* ====== TIME FORMATTERS ====== */
function fmtTimeTZ(d, opts = {}) {
  try {
    return new Intl.DateTimeFormat("en-US", {
      timeZone: cfg.tz, hour12: true, hour: "numeric", minute: "2-digit", ...opts
    }).format(d);
  } catch (e) {
    // Fallback when QS webview lacks IANA tz support
    return new Intl.DateTimeFormat("en-US", {
      hour12: true, hour: "numeric", minute: "2-digit", ...opts
    }).format(d);
  }
}

function fmtDateTZ(d) {
  try {
    return new Intl.DateTimeFormat("en-US", {
      timeZone: cfg.tz, weekday: "short", year: "numeric", month: "short", day: "2-digit"
    }).format(d);
  } catch (e) {
    // Fallback
    return new Intl.DateTimeFormat("en-US", {
      weekday: "short", year: "numeric", month: "short", day: "2-digit"
    }).format(d);
  }
}

/* ====== BUILD DATES ====== */
const T = {
  standby:    parseFlex(cfg.standby),
  activation: parseFlex(cfg.activation),
  start:      parseFlex(cfg.start),
  end:        parseFlex(cfg.end)
};

// Dial day: from eventDate if present, else from start date (in tz)
let dialStart, dialEnd;
if (cfg.eventDate){
  const d0 = parseFlex(cfg.eventDate, { isDateOnly:true });
  // construct 00:00 and 23:59:59 same day
  dialStart = new Date(d0); dialStart.setHours(0,0,0,0);
  dialEnd   = new Date(d0); dialEnd.setHours(23,59,59,999);
} else {
  const base = T.start ? new Date(T.start) : new Date();
  dialStart = new Date(base); dialStart.setHours(0,0,0,0);
  dialEnd   = new Date(base); dialEnd.setHours(23,59,59,999);
}

/* ====== ANGLE MAP (24h dial) ====== */
function angleFor(d, dayStart, dayEnd){
  const span = dayEnd - dayStart;
  const clamped = Math.max(dayStart, Math.min(d, dayEnd));
  const t = (clamped - dayStart) / span; // 0..1
  return (t * 360) - 90; // 0 at top, clockwise
}

/* ====== SVG DRAW ====== */
const svgNS = "http://www.w3.org/2000/svg";
const host = document.getElementById('clock-host');
const tip  = document.getElementById('tip');
const W = 460, H = 460, CX = W/2, CY = H/2;
const R_OUT = 180;
const THK  = 26;

// ---- Tooltip positioning helper (relative to #clock-host) ----
function placeTipRelativeToHost(evt){
  const hostEl = document.getElementById('clock-host');   // the container that also holds .tip
  const r = hostEl.getBoundingClientRect();
  const x = evt.clientX - r.left; // relative X inside host
  const y = evt.clientY - r.top;  // relative Y inside host
  tip.style.left = x + 'px';
  tip.style.top  = y + 'px';
}

function pc(cx, cy, r, deg){
  const rad = (deg * Math.PI) / 180;
  return { x: cx + r * Math.cos(rad), y: cy + r * Math.sin(rad) };
}
function arcPath(cx, cy, rOuter, thickness, a0, a1){
  const rInner = rOuter - thickness;
  const p0 = pc(cx, cy, rOuter, a0), p1 = pc(cx, cy, rOuter, a1);
  const q1 = pc(cx, cy, rInner, a1), q0 = pc(cx, cy, rInner, a0);
  const large = Math.abs((a1 - a0 + 360) % 360) > 180 ? 1 : 0;
  const sweep = a1 > a0 ? 1 : 0;
  return [
    `M ${p0.x} ${p0.y}`,
    `A ${rOuter} ${rOuter} 0 ${large} ${sweep} ${p1.x} ${p1.y}`,
    `L ${q1.x} ${q1.y}`,
    `A ${rInner} ${rInner} 0 ${large} ${sweep ^ 1} ${q0.x} ${q0.y}`,
    'Z'
  ].join(' ');
}

const svg = document.createElementNS(svgNS, "svg");
svg.setAttribute("width", W);
svg.setAttribute("height", H);
host.prepend(svg);

// base ring + 24h ticks
(function drawBase(){
  const base = document.createElementNS(svgNS,'circle');
  base.setAttribute('cx', CX); base.setAttribute('cy', CY);
  base.setAttribute('r', R_OUT + 6);
  base.setAttribute('fill','none');
  base.setAttribute('stroke','var(--ring)');
  base.setAttribute('stroke-width','12');
  svg.appendChild(base);

  for(let h=0; h<24; h++){
    const angle = (h/24)*360 - 90;
    const r1 = R_OUT + 10;
    const major = (h%6===0);
    const r2 = r1 + (major ? 14 : 8);
    const p1 = pc(CX,CY,r1,angle);
    const p2 = pc(CX,CY,r2,angle);
    const line = document.createElementNS(svgNS,'line');
    line.setAttribute('x1',p1.x); line.setAttribute('y1',p1.y);
    line.setAttribute('x2',p2.x); line.setAttribute('y2',p2.y);
    line.setAttribute('stroke','var(--tick)');
    line.setAttribute('stroke-width', major ? 2 : 1);
    svg.appendChild(line);

    if(major){
      const t = document.createElementNS(svgNS,'text');
      const label = h.toString().padStart(2,'0');
      const tp = pc(CX,CY,r2+14,angle);
      t.textContent = label;
      t.setAttribute('x', tp.x);
      t.setAttribute('y', tp.y);
      t.setAttribute('fill', 'var(--muted)');
      t.setAttribute('font-size','10');
      t.setAttribute('text-anchor','middle');
      t.setAttribute('dominant-baseline','middle');
      svg.appendChild(t);
    }
  }
})();

/* ====== ANGLES (aligned ring) ====== */
const A = {
  standby:    T.standby    ? angleFor(T.standby,    dialStart, dialEnd) : null,
  activation: T.activation ? angleFor(T.activation, dialStart, dialEnd) : null,
  start:      T.start      ? angleFor(T.start,      dialStart, dialEnd) : null,
  end:        T.end        ? angleFor(T.end,        dialStart, dialEnd) : null
};

/* ====== SEGMENTS ====== */
function addSegment(a0, a1, color, title, start, end){
  if(a0===null || a1===null) return;
  const g = document.createElementNS(svgNS,'g');
  const seg = document.createElementNS(svgNS,'path');
  seg.setAttribute('d', arcPath(CX,CY,R_OUT,THK,a0,a1));
  seg.setAttribute('fill', color);
  seg.setAttribute('fill-opacity','0.9');
  seg.setAttribute('stroke','rgba(255,255,255,0.08)');
  seg.setAttribute('stroke-width','1');
  seg.style.cursor = 'pointer';
  seg.addEventListener('mousemove', (e)=>{
  tip.style.opacity = 1;
  placeTipRelativeToHost(e);
});
seg.addEventListener('mouseleave', ()=> tip.style.opacity = 0 );


  // label at midpoint
  const mid = (a0 + a1)/2;
  const lp = pc(CX,CY,R_OUT - THK/2, mid);
  const text = document.createElementNS(svgNS,'text');
  text.textContent = title;
  text.setAttribute('x', lp.x);
  text.setAttribute('y', lp.y);
  text.setAttribute('fill','#0a0a0a');
  text.setAttribute('font-size','10');
  text.setAttribute('font-weight','700');
  text.setAttribute('text-anchor','middle');
  text.setAttribute('dominant-baseline','middle');
  const pill = document.createElementNS(svgNS,'rect');
  const tw = title.length * 6.2 + 12;
  const th = 14;
  pill.setAttribute('x', lp.x - tw/2);
  pill.setAttribute('y', lp.y - th/2);
  pill.setAttribute('rx', 7); pill.setAttribute('ry', 7);
  pill.setAttribute('width', tw); pill.setAttribute('height', th);
  pill.setAttribute('fill','rgba(255,255,255,0.18)');
  pill.setAttribute('stroke','rgba(0,0,0,0.15)');

  // tooltip
if(start && end){
  const mins = Math.round((end - start)/60000);
  const hh = Math.floor(mins/60), mm = mins%60;
  seg.addEventListener('mouseenter', (e)=>{
    tip.style.opacity = 1;
    placeTipRelativeToHost(e);
    tip.innerHTML = `<strong>${title}</strong><br>${fmtTimeTZ(start)} → ${fmtTimeTZ(end)}<br><span class="muted">${fmtDateTZ(start)}</span><br><span class="muted">${hh}h ${mm}m</span>`;
  });
}

  g.appendChild(seg); g.appendChild(pill); g.appendChild(text);
  svg.appendChild(g);
}

/* Draw segments (use what’s provided) */
if (A.standby !== null && A.activation !== null)
  addSegment(A.standby, A.activation, 'var(--standby)',   'Standby',    T.standby, T.activation);
if (A.activation !== null && A.start !== null)
  addSegment(A.activation, A.start,   'var(--activation)','Activation', T.activation, T.start);
if (A.start !== null && A.end !== null)
  addSegment(A.start, A.end,         'var(--event)',     'Event',      T.start, T.end);

/* ====== KPIs & FOOTER ====== */
function durFmt(ms){ const m = Math.round(ms/60000); const h = Math.floor(m/60), mm = m%60; return `${h}h ${mm}m`; }
const kEvent = document.getElementById('k_event');
const kLead  = document.getElementById('k_lead');
const kSB    = document.getElementById('k_sb');
const kDay   = document.getElementById('k_day');
kEvent.textContent = (T.start && T.end) ? `${fmtTimeTZ(T.start)} – ${fmtTimeTZ(T.end)} (${durFmt(T.end - T.start)})` : '—';
kLead.textContent  = (T.activation && T.start) ? durFmt(T.start - T.activation) : '—';
kSB.textContent    = (T.standby && T.activation) ? durFmt(T.activation - T.standby) : '—';
kDay.textContent   = fmtDateTZ(dialStart);
document.getElementById('footerText').textContent = `Event #${cfg.eventId} • ${cfg.useCase} • TZ: ${cfg.tz}`;
</script>
</body>
</html>
